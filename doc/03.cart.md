# 장바구니 구현

## 다소 민감한 개인정보

- 기본적인 장바구니 정보(상품 ID, 수량 등)는 민감한 개인정보로 보기 어렵다.
- 단, 사용자의 구매 패턴이나 선호도를 유추할 수 있는 정보이므로 적절한 보안 조치는 필요하다.

## Redux + localStorage 활용한 구현

- Redux로 실시간 상태 관리
- localStorage에 백업하여 새로고침해도 유지
- 로그인한 사용자의 경우 서버와 동기화

## 장바구니 전체 동기화 vs. 개별 동기화

전체 동기화의 장점

- 구현이 단순함 - 하나의 엔드포인트로 모든 작업 처리
- 클라이언트-서버 상태 불일치 방지가 쉬움
- 네트워크 요청 실패 시 재시도가 간단함
- 작은 용량(보통 수십개 이하의 아이템)이라 성능 차이 미미

개별 동기화의 장점

- 장바구니 아이템이 수백개 이상으로 매우 큰 경우
- 네트워크 대역폭이 매우 제한적인 경우
- 여러 사용자가 동시에 같은 장바구니를 수정하는 경우

일반적인 쇼핑몰의 경우 장바구니 크기가 크지 않으므로, 전체 동기화 방식이 구현/유지보수 측면에서 더 낫다.

## 구현 로직

1. 각 작업마다 먼저 로컬 Redux 상태 업데이트
2. 그 다음 변경된 전체 장바구니 상태를 백엔드와 동기화
3. Redux 상태 변경시 자동으로 localStorage도 업데이트 (slice에서 처리)

## 추가사항

에러 핸들링

현재 syncCart 실패 시의 에러 처리가 명시적이지 않습니다
네트워크 오류나 서버 오류 시 사용자에게 적절한 피드백을 주는 것이 좋겠습니다

동시성 제어:

@Version을 사용해 낙관적 락을 구현한 것은 좋습니다.
하지만 현재 syncCart에서 충돌 처리 로직이 없습니다.

JSON 데이터 처리:

cartData를 String으로 저장하고 있는데, 검증이 충분하지 않습니다.
JSON 파싱 실패에 대한 예외 처리가 필요합니다.

도메인 모델의 불변성:

Cart 모델이 불변 객체를 지향하고 있지만, JSON 데이터의 유효성을 완전히 보장하지 못합니다.